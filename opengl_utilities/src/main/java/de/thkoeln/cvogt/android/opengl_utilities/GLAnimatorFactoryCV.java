// This work is provided under GPLv3, the GNU General Public License 3
//   http://www.gnu.org/licenses/gpl-3.0.html

// Prof. Dr. Carsten Vogt
// Technische Hochschule Köln, Germany
// Fakultät für Informations-, Medien- und Elektrotechnik
// carsten.vogt@th-koeln.de
// 21.1.2023

package de.thkoeln.cvogt.android.opengl_utilities;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.animation.TypeEvaluator;
import android.animation.ValueAnimator;
import android.opengl.Matrix;
import android.util.Log;
import android.view.animation.LinearInterpolator;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * Class with static convenience methods to create animators for shapes.
 * These animators can be attached to shapes through the <I>addAnimator()</I> method of a shape.
 * <P>
 * An animator affects the model matrix of a shape, i.e. the placement of the shape in the world by scaling, rotating, and translating it.
 * Animators that work in the model coordinate space, i.e. modify the form of the shape ("morph" the shape) can be implemented through the control thread of the shape.
 * <P>
 * As animation is based on the "property animation" technique provided by Android,
 * all methods of the Android Java class <I>ObjectAnimator</I> can be applied to the animators generated by the methods of this class
 * (e.g. <I>setInterpolator()</I> to assign a time interpolator to control the timing of the animator).
 * <P>
 * Currently, these animations are supported:
 * <UL>
 * <P><LI>Scaling, rotation, translation
 * <P><LI>Discrete movement through a sequence of points
 * <P><LI>Movement through a sequence of paths
 * <P><LI>Alignment with a vector or another shape
 * <P><LI>Placement between two given points in space
 * <P><LI>Circular movement around a given arc by a given angle
 * <P><LI>Spiral movement around a given arc
 * <P><LI>Movement along a Bezier curve
 * </UL>
 * <BR>
 * @see GLShapeCV
 */

// TODO WEITERE ANIMATOREN - SIEHE DAZU AUCH METHODEN ADDXXXANIMATOR DER KLASSE ANIMATORGUIOBJECTCV IM PROJEKT UTILITIESPROPANIMCV

public class GLAnimatorFactoryCV {

    /**
     * Makes an animator to scale a shape in the x dimension.
     * @param scaleFactor The target scale factor of the animation.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimScaleX(float scaleFactor, int duration) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(null, "scaleX", scaleFactor);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to scale a shape in the y dimension.
     * @param scaleFactor The target scale factor of the animation.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimScaleY(float scaleFactor, int duration) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(null, "scaleY", scaleFactor);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to scale a shape in the z dimension.
     * @param scaleFactor The target scale factor of the animation.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimScaleZ(float scaleFactor, int duration) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(null, "scaleZ", scaleFactor);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to scale a shape in all three dimension.
     * @param scaleFactor The target scale factor of the animation.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimScale(float scaleFactor, int duration) {
        // ObjectAnimator animator = ObjectAnimator.ofFloat(shape, "scale", scaleFactor);
        ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder((GLShapeCV)null,PropertyValuesHolder.ofFloat("scaleX",scaleFactor),
                PropertyValuesHolder.ofFloat("scaleY",scaleFactor),PropertyValuesHolder.ofFloat("scaleZ",scaleFactor));
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to let a shape make a rotation around the x axis of the world coordinate system.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimRotX(float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        float[] axis = { 1, 0, 0 };
        return makeAnimRot(angleToTraverse,axis,duration,repeatCount,reverse);
    }

    /**
     * Makes an animator to let a shape make a rotation around the y axis of the world coordinate system.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimRotY(float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        float[] axis = { 0, 1, 0 };
        return makeAnimRot(angleToTraverse,axis,duration,repeatCount,reverse);
    }

    /**
     * Makes an animator to let a shape make a rotation around the z axis of the world coordinate system.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimRotZ(float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        float[] axis = { 0, 0, 1 };
        return makeAnimRot(angleToTraverse,axis,duration,repeatCount,reverse);
    }

    /**
     * Makes an animator to let a shape make a rotation around a specified axis of the world coordinate system.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param angleToTraverse The rotation angle to traverse.
     * @param axis The rotation axis.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimRot(float angleToTraverse, float[] axis, int duration, int repeatCount, boolean reverse) {
        EvaluatorRot eval = new EvaluatorRot(angleToTraverse,axis);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject((GLShapeCV)null,"rotationMatrix",eval,dummy,dummy);
        eval.setAnimator(animator);
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        if (reverse)
            animator.setRepeatMode(ValueAnimator.REVERSE);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Class that defines a TypeEvaluator for a rotation around an axis in the world coordinate system - see method addAnimatorRot().
     */

    private static class EvaluatorRot implements TypeEvaluator<float[]> {
        private ObjectAnimator animator;   // the animator to which this evaluator belongs
        private float[] startRotMatrix; // rotation matrix of the shape when the rotation starts
        private final float angleToTraverse;  // rotation angle to traverse in the animation
        private final float[] axis;           // rotation axis of the animation
        private boolean attributeIsValid;

        EvaluatorRot(float angleToTraverse, float[] axis) {
            this.angleToTraverse = angleToTraverse;
            this.axis = axis.clone();
            this.attributeIsValid = false;
        }

        public void setAnimator(ObjectAnimator animator) {
            this.animator = animator;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (!attributeIsValid) {
                GLShapeCV shape = (GLShapeCV) animator.getTarget();
                startRotMatrix = shape.getRotationMatrix();
                // for debugging purposes
                // float rotAngleInit = GraphicsUtilsCV.rotAngleFrom4x4RotationMatrix(GraphicsUtilsCV.matrixFromArray(startRotMatrix,4,4));
                // float[] rotAxisInit = GraphicsUtilsCV.rotAxisFrom4x4RotationMatrix(GraphicsUtilsCV.matrixFromArray(startRotMatrix,4,4));
                // Log.v("GLDEMO","AnimatorRot: "+rotAngleInit+"  "+rotAxisInit[0]+" "+rotAxisInit[1]+" "+rotAxisInit[2]);
                attributeIsValid = true;
            }
            float currentRotAngle = f*angleToTraverse;
            // Log.v("GLDEMO","animator: "+currentRotAngle+"  "+axis[0]+" "+axis[1]+" "+axis[2]);
            float[] rotMatrix = new float[16];
            Matrix.setRotateM(rotMatrix,0,currentRotAngle,axis[0],axis[1],axis[2]);
            Matrix.multiplyMM(rotMatrix,0,rotMatrix,0,startRotMatrix,0);
            /*
            float[] result = new float[4];
            float[][] rotMatrix2Dim = GraphicsUtilsCV.matrixFromArray(rotMatrix,4,4);
            result[0] = GraphicsUtilsCV.rotAngleFrom4x4RotationMatrix(rotMatrix2Dim);
            float[] tmp = GraphicsUtilsCV.rotAxisFrom4x4RotationMatrix(rotMatrix2Dim);
            result[1] = tmp[0];
            result[2] = tmp[1];
            result[3] = tmp[2];
            return result; */
            return rotMatrix;
        }

    }

    /**
     * Makes an animator to let a shape make a rotation to align it with a given vector.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param axisToAlign The axis of the shape to be aligned with vector - 0 = x axis, 1 = y axis, 2 = z axis.
     * @param vectorToAlignWith The vector to align the shape with.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator (or null if the shape is already aligned with the vector).
     */

    public static ObjectAnimator makeAnimRotAlign(int axisToAlign, float[] vectorToAlignWith, int duration) {
        float[] shapeAxisToAlign = new float[4];
        shapeAxisToAlign[axisToAlign] = 1;
        if (GraphicsUtilsCV.linearlyDependent(shapeAxisToAlign,vectorToAlignWith)) return null;
        EvaluatorRotAlignWithVector eval = new EvaluatorRotAlignWithVector(axisToAlign,vectorToAlignWith);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject((GLShapeCV)null,"rotationMatrix",eval,dummy,dummy);
        eval.setAnimator(animator);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
        /*
        float[] shapeAxis = new float[4];
        shapeAxis[axisToAlign] = 1;
        Matrix.multiplyMV(shapeAxis,0,shape.getRotationMatrix(),0,shapeAxis,0);
        float[] shapeAxisShort = new float[3];
        for (int i=0;i<3;i++)
            shapeAxisShort[i] = shapeAxis[i];
        float[] shapeAxisNormalized = GraphicsUtilsCV.getNormalizedCopy(shapeAxisShort);
        float[] alignmentVectorNormalized = GraphicsUtilsCV.getNormalizedCopy(vectorToAlignWith);
        float[] axis = GraphicsUtilsCV.crossProduct(shapeAxisNormalized,alignmentVectorNormalized);
        float angle = (float) (180*Math.acos(GraphicsUtilsCV.dotProduct(shapeAxisNormalized,alignmentVectorNormalized))/Math.PI);
        return addAnimatorRot(shape,angle,axis,duration,0,false);
        */
    }

    /**
     * Class that defines a TypeEvaluator to align a shape with a vector.
     */

    private static class EvaluatorRotAlignWithVector implements TypeEvaluator<float[]> {
        private ObjectAnimator animator;   // the animator to which this evaluator belongs
        private float[] startRotMatrix;
        private final float[] shapeAxisToAlign;
        private final float[] vectorToAlignWith;
        private float[] rotAxis;
        private float rotAngle;
        private boolean attributeIsValid;

        EvaluatorRotAlignWithVector(int axisToAlign, float[] vectorToAlignWith) {
            this.shapeAxisToAlign = new float[4];
            this.shapeAxisToAlign[axisToAlign] = 1;
            this.vectorToAlignWith = vectorToAlignWith.clone();
            this.attributeIsValid = false;
        }

        public void setAnimator(ObjectAnimator animator) {
            this.animator = animator;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (!attributeIsValid) {
                GLShapeCV shape = (GLShapeCV) animator.getTarget();
                startRotMatrix = shape.getRotationMatrix();
                // float rotAngleInit = GraphicsUtilsCV.rotAngleFrom4x4RotationMatrix(GraphicsUtilsCV.matrixFromArray(startRotMatrix,4,4));
                // float[] rotAxisInit = GraphicsUtilsCV.rotAxisFrom4x4RotationMatrix(GraphicsUtilsCV.matrixFromArray(startRotMatrix,4,4));
                // Log.v("GLDEMO","AnimatorAlign: "+rotAngleInit+"  "+rotAxisInit[0]+" "+rotAxisInit[1]+" "+rotAxisInit[2]);
                Matrix.multiplyMV(shapeAxisToAlign,0,startRotMatrix,0,shapeAxisToAlign,0);
                float[] shapeAxisShort = new float[3];
                for (int i=0;i<3;i++)
                    shapeAxisShort[i] = this.shapeAxisToAlign[i];
                GraphicsUtilsCV.normalizeVector3D(shapeAxisShort);
                GraphicsUtilsCV.normalizeVector3D(vectorToAlignWith);
                rotAxis = GraphicsUtilsCV.crossProduct3D(shapeAxisShort,vectorToAlignWith);
                rotAngle = (float) (180*Math.acos(GraphicsUtilsCV.dotProduct3D(shapeAxisShort,vectorToAlignWith))/Math.PI);
                attributeIsValid = true;
            }
            float currentRotAngle = f*rotAngle;
            float[] rotMatrix = new float[16];
            if (GraphicsUtilsCV.isZero(currentRotAngle))
                Matrix.setIdentityM(rotMatrix, 0);
            else
                Matrix.setRotateM(rotMatrix,0,currentRotAngle,rotAxis[0],rotAxis[1],rotAxis[2]);
            Matrix.multiplyMM(rotMatrix,0,rotMatrix,0,startRotMatrix,0);
            return rotMatrix;
        }

    }

    /**
     * Makes an animator to let a shape make a rotation to align it
     * (i.e. the orientation of its model coordinate system in world space)
     * with another shape (i.e. with the model coordinate system of that shape).
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param shapeToAlignWith The other shape to which the shape shall be aligned.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimRotAlign(GLShapeCV shapeToAlignWith, int duration) {
        EvaluatorRotAlignWithShape eval = new EvaluatorRotAlignWithShape(shapeToAlignWith);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject((GLShapeCV)null,"rotationMatrix",eval,dummy,dummy);
        eval.setAnimator(animator);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Class that defines a TypeEvaluator to align a shape with another shape.
     */

    private static class EvaluatorRotAlignWithShape implements TypeEvaluator<float[]> {
        private ObjectAnimator animator;   // the animator to which this evaluator belongs
        private final GLShapeCV shapeToAlignWith;
        private float[] startRotMatrix;
        private float[] vectorToAlignWith;
        private float[] rotAxis;
        private float rotAngle;
        private boolean attributeIsValid;

        EvaluatorRotAlignWithShape(GLShapeCV shapeToAlignWith) {
            this.shapeToAlignWith = shapeToAlignWith;
            this.attributeIsValid = false;
        }

        public void setAnimator(ObjectAnimator animator) {
            this.animator = animator;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (!attributeIsValid) {
                GLShapeCV shape = (GLShapeCV) animator.getTarget();
                startRotMatrix = shape.getRotationMatrix();
                float[] rotMatrix1 = shapeToAlignWith.getRotationMatrix();
                float[] rotMatrix2 = shape.getRotationMatrix();
                float[] inversRotMatrix = new float[16];
                Matrix.invertM(inversRotMatrix, 0, rotMatrix2, 0);
                float[] animRotMatrix = new float[16];
                Matrix.multiplyMM(animRotMatrix, 0, rotMatrix1, 0, inversRotMatrix, 0);
                float[][] animRotMatrix2D = GraphicsUtilsCV.matrixFromArray(animRotMatrix, 4, 4);
                rotAngle = -GraphicsUtilsCV.rotAngleFrom4x4RotationMatrix(animRotMatrix2D);
                rotAxis = GraphicsUtilsCV.rotAxisFrom4x4RotationMatrix(animRotMatrix2D);
                attributeIsValid = true;
            }
            float currentRotAngle = f*rotAngle;
            float[] rotMatrix = new float[16];
            Matrix.setRotateM(rotMatrix,0,currentRotAngle,rotAxis[0],rotAxis[1],rotAxis[2]);
            Matrix.multiplyMM(rotMatrix,0,rotMatrix,0,startRotMatrix,0);
            return rotMatrix;
        }

    }

    /**
     * Makes an animator to let a shape rotate around its own x axis,
     * i.e. the axis in its model coordinate space.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimRotEulerX(float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        return makeAnimRotEuler(0,angleToTraverse,duration,repeatCount,reverse);
    }

    /**
     * Makes an animator to let a shape rotate around its own y axis,
     * i.e. the axis in its model coordinate space.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimRotEulerY(float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        return makeAnimRotEuler(1,angleToTraverse,duration,repeatCount,reverse);
    }

    /**
     * Makes an animator to let a shape rotate around its own z axis,
     * i.e. the axis in its model coordinate space.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimRotEulerZ(float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        return makeAnimRotEuler(2,angleToTraverse,duration,repeatCount,reverse);
    }

    /**
     * Makes an animator to let a shape rotate around its own x, y, or z axis,
     * i.e. the axis in its model coordinate space.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param axisId The rotation axis - 0 = x, 1 = y, 2 = z.
     * @param angleToTraverse The rotation angle to traverse.
     * @param duration The duration of the animation (ms).
     * @param repeatCount The number of times the animation shall be repeated.
     * @param reverse true if the animation shall be reversed.
     * @return The newly generated animator.
     */

    private static ObjectAnimator makeAnimRotEuler(int axisId, float angleToTraverse, int duration, int repeatCount, boolean reverse) {
        EvaluatorRotEuler eval = new EvaluatorRotEuler(axisId,angleToTraverse);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject((GLShapeCV)null,"rotationMatrix",eval,dummy,dummy);
        eval.setAnimator(animator);
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Class that defines a TypeEvaluator for a rotation around the x, y, or z axis in the model coordinate system.
     */

    private static class EvaluatorRotEuler implements TypeEvaluator<float[]> {
        private ObjectAnimator animator;   // the animator to which this evaluator belongs
        private final int axisId; // 0 = x axis, 2 = y axis, 3 = z axis
        private float[] startRotMatrix; // rotation matrix of the shape when the rotation starts
        float[] axis = new float[4]; // axis in the world coordinate space around which the shape is rotated,
                                     // results from rotating the shape-specific x, z, or y axis by startRotMatrix
        private final float angleToTraverse;
        private boolean attributeIsValid;

        EvaluatorRotEuler(int axisId, float angleToTraverse) {
            this.angleToTraverse = angleToTraverse;
            this.axisId = axisId;
            this.attributeIsValid = false;
        }

        public void setAnimator(ObjectAnimator animator) {
            this.animator = animator;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (!attributeIsValid) {
                GLShapeCV shape = (GLShapeCV) animator.getTarget();
                startRotMatrix = shape.getRotationMatrix();
                attributeIsValid = true;
                // calculate the rotated x, z, or y axis
                float[] axisPoint1 = {0,0,0,1}, axisPoint2 = {0,0,0,1};
                axisPoint2[axisId] = 1;
                Matrix.multiplyMV(axisPoint1,0,startRotMatrix,0,axisPoint1,0);
                Matrix.multiplyMV(axisPoint2,0,startRotMatrix,0,axisPoint2,0);
                for (int i=0;i<4;i++)
                    axis[i] = axisPoint1[i]-axisPoint2[i];
            }
            float currentAngle = f*angleToTraverse;
            float[] rotMatrix = new float[16];
            Matrix.setRotateM(rotMatrix,0,currentAngle,axis[0],axis[1],axis[2]);
            Matrix.multiplyMM(rotMatrix,0,rotMatrix,0,startRotMatrix,0);
            return rotMatrix;
        }

    }

    /**
     * Makes an animator to let a shape "pitch", i.e. move up and down rotating around its x axis.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param maxAngle The maximum angle by which the object is moved up or down.
     * @param duration The duration of a full round (= movement of the shape in both directions and return to the start position).
     * @param repeatCount The number of times the animation shall be repeated.
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimRotPitch(float maxAngle, int duration, int repeatCount) {
        return makeAnimRotPitchRollYaw(0,maxAngle,duration,repeatCount);
    }

    /**
     * Makes an animator to let a shape "roll" around its z axis.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param maxAngle The maximum angle by which the object is roll.
     * @param duration The duration of a full round (= movement of the shape in both directions and return to the start position).
     * @param repeatCount The number of times the animation shall be repeated.
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimRotRoll(float maxAngle, int duration, int repeatCount) {
        return makeAnimRotPitchRollYaw(1,maxAngle,duration,repeatCount);
    }

    /**
     * Makes an animator to let a shape "yaw", i.e. move left and right rotating around its y axis.
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param maxAngle The maximum angle by which the object is moved left or right.
     * @param duration The duration of a full round (= movement of the shape in both directions and return to the start position).
     * @param repeatCount The number of times the animation shall be repeated.
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimRotYaw(float maxAngle, int duration, int repeatCount) {
        return makeAnimRotPitchRollYaw(2,maxAngle,duration,repeatCount);
    }

    /**
     * Makes an animator to let a shape pitch, roll, or yaw
     * <BR>
     * N.B. All rotation animators that affect the rotation matrix of a shape
     * (i.e. its orientation in space) exclude each others,
     * i.e. only one such rotation animation can run at the same time.
     * Its is however possible to assign multiple rotation animators to the same shape
     * that are executed sequentially.
     * @param type The type of the movement - 0 = pitch, 1 = roll, 2 = yaw.
     * @param maxAngle The maximum angle by which the object is moved.
     * @param duration The duration of a full round (= movement of the shape in both directions and return to the start position).
     * @param repeatCount The number of times the animation shall be repeated.
     * @return The newly generated animator.
     */

    private static ObjectAnimator makeAnimRotPitchRollYaw(int type, float maxAngle, int duration, int repeatCount) {
        EvaluatorRotPitchRollYaw eval = new EvaluatorRotPitchRollYaw(maxAngle,type);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject((Object)null,"rotationMatrix",eval,dummy,dummy);
        eval.setAnimator(animator);
        animator.setDuration(duration);
        animator.setRepeatCount(repeatCount);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Class that defines a TypeEvaluator for a pitch, roll, or yaw animation.
     */

    private static class EvaluatorRotPitchRollYaw implements TypeEvaluator<float[]> {
        private ObjectAnimator animator;   // the animator to which this evaluator belongs
        private final int type; // 0 = pitch, 1 = roll, 2 = yaw
        private float[] startRotMatrix; // rotation matrix of the shape when the rotation starts
        float[] axis = new float[4]; // axis world coordinate space around which the shape is pitched, rolled, or yawed;
                                     // results from rotating the shape-specific x, z, or y axis by startRotMatrix
        private final float maxAngle;  // maximum angle by which the shape shall be moved
        private boolean attributeIsValid;

        EvaluatorRotPitchRollYaw(float maxAngle, int type) {
            this.maxAngle = maxAngle;
            this.type = type;
            this.attributeIsValid = false;
        }

        public void setAnimator(ObjectAnimator animator) {
            this.animator = animator;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (!attributeIsValid) {
                GLShapeCV shape = (GLShapeCV) animator.getTarget();
                startRotMatrix = shape.getRotationMatrix();
                attributeIsValid = true;
                // calculate the rotated x, z, or y axis
                float[] axisPoint1 = {0,0,0,1}, axisPoint2 = {0,0,0,1};
                switch (type) {
                    case 0: axisPoint2[0] = 1; break; // pitch = rotation around x axis
                    case 1: axisPoint2[2] = 1; break; // roll = rotation around z axis
                    case 2: axisPoint2[1] = 1; break; // yaw = rotation around y axis
                }
                Matrix.multiplyMV(axisPoint1,0,startRotMatrix,0,axisPoint1,0);
                Matrix.multiplyMV(axisPoint2,0,startRotMatrix,0,axisPoint2,0);
                for (int i=0;i<4;i++)
                    axis[i] = axisPoint1[i]-axisPoint2[i];
            }
            float currentAngle;
            if (f<0.25)
                currentAngle = -f*4*maxAngle;
            else if (f<0.5)
                currentAngle = -maxAngle+(f-.25f)*4*maxAngle;
            else if (f<0.75)
                currentAngle = (f-.5f)*4*maxAngle;
            else
                currentAngle = maxAngle-(f-0.75f)*4*maxAngle;
            float[] rotMatrix = new float[16];
            // pitch, roll, or yaw around the rotated x, z, or y matrix
            Matrix.setRotateM(rotMatrix,0,currentAngle,axis[0],axis[1],axis[2]);
            Matrix.multiplyMM(rotMatrix,0,rotMatrix,0,startRotMatrix,0);
            return rotMatrix;
        }

    }

    /**
     * Makes an animator to let a shape move on a direct line to a specific x position, with its y and z coordinates unchanged.
     * @param targetX The target x position of the animation.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimTransLinearToX(float targetX, int duration) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(null, "transX", targetX);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to let a shape move on a direct line to a specific y position, with its x and z coordinates unchanged.
     * @param targetY The target y position of the animation.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimTransLinearToY(float targetY, int duration) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(null, "transY", targetY);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to let a shape move on a direct line to a specific z position, with its x and y coordinates unchanged.
     * @param targetZ The target z position of the animation.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimTransLinearToZ(float targetZ, int duration) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(null, "transZ", targetZ);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to let a shape move on a direct line to a specific (x,y,z) position.
     * @param targetX The target x position of the animation.
     * @param targetY The target y position of the animation.
     * @param targetZ The target z position of the animation.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimTransLinearTo(float targetX, float targetY, float targetZ, int duration) {
        ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder((GLShapeCV)null,PropertyValuesHolder.ofFloat("transX",targetX),
                PropertyValuesHolder.ofFloat("transY",targetY),PropertyValuesHolder.ofFloat("transZ",targetZ));
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to let a shape move on a direct line to a specific (x,y,z) position.
     * @param target The target  position of the animation.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator or null if the target parameter is not valid, i.e. not an array of length 3.
     */

    public static ObjectAnimator makeAnimTransLinearTo(float[] target, int duration) {
        return makeAnimTransLinearTo(target[0],target[1],target[2],duration);
    }

    /**
     * Makes an animator to move a shape on a direct line from its current x position to a new x position by a specific distance,
     * with its y and z coordinates unchanged.
     * @param translationX The distance into the x direction by which the shape shall be moved.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimTransLinearByX(float translationX, int duration) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(null, "transX", 0);
        animator.setDuration(duration);
        animator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                GLShapeCV shape = (GLShapeCV)animator.getTarget();
                animator.setFloatValues(shape.getTransX(),shape.getTransX()+translationX);
            }
        });
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to move a shape on a direct line from its current y position to a new y position by a specific distance,
     * with its x and z coordinates unchanged.
     * @param translationY The distance into the y direction by which the shape shall be moved.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimTransLinearByY(float translationY, int duration) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(null, "transY", 0);
        animator.setDuration(duration);
        animator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                GLShapeCV shape = (GLShapeCV)animator.getTarget();
                animator.setFloatValues(shape.getTransY(),shape.getTransY()+translationY);
            }
        });
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to move a shape on a direct line from its current z position to a new z position by a specific distance,
     * with its x and y coordinates unchanged.
     * @param translationZ The distance into the z direction by which the shape shall be moved.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimTransLinearByZ(float translationZ, int duration) {
        ObjectAnimator animator = ObjectAnimator.ofFloat(null, "transZ", 0);
        animator.setDuration(duration);
        animator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                GLShapeCV shape = (GLShapeCV)animator.getTarget();
                animator.setFloatValues(shape.getTransZ(),shape.getTransZ()+translationZ);
            }
        });
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to move a shape on a direct line from its current position by a specific vector.
     * @param translationX The x component of the vector.
     * @param translationY The y component of the vector.
     * @param translationZ The z component of the vector.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimTransLinearBy(float translationX, float translationY, float translationZ, int duration) {
        PropertyValuesHolder propHolderX = PropertyValuesHolder.ofFloat("transX",0);
        PropertyValuesHolder propHolderY = PropertyValuesHolder.ofFloat("transY",0);
        PropertyValuesHolder propHolderZ = PropertyValuesHolder.ofFloat("transZ",0);
        ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder((GLShapeCV)null,
                propHolderX, propHolderY, propHolderZ);
        animator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                GLShapeCV shape = (GLShapeCV)animator.getTarget();
                propHolderX.setFloatValues(shape.getTransX(),shape.getTransX()+translationX);
                propHolderY.setFloatValues(shape.getTransY(),shape.getTransY()+translationY);
                propHolderZ.setFloatValues(shape.getTransZ(),shape.getTransZ()+translationZ);
            }
        });
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to move a shape from its current position on a direct line defined by a vector.
     * @param translationVector The vector as an array of length 3 (x,y,z).
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator or null if the vector is not valid.
     */

    public static ObjectAnimator makeAnimTransLinearBy(float[] translationVector, int duration) {
        if (translationVector==null||translationVector.length!=3) return null;
        return makeAnimTransLinearBy(translationVector[0],translationVector[1],translationVector[2],duration);
    }

    /**
     * Makes an animator to move a shape linearly on a line between its initial position and a given point,
     * i.e. attracts it to this point or repels it from it.
     * @param point The point.
     * @param factor The factor determining the direction and length of the movement.
     *               The vector between the target shape position and the point is the vector between the initial shape position and the point multiplied by factor.
     *               Hence, if factor>1 the shape is repelled from the point and if 1>factor>0 it is attracted to the point.
     *               If factor<0 the shape will be moved to the point and beyond it.
     * @param duration The duration of the animation (ms).
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimTransAttractRepel(float[] point, float factor, int duration) {
        EvaluatorTransAttractRepel eval = new EvaluatorTransAttractRepel(point,factor);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject((Object)null,"trans",eval,dummy,dummy);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        eval.setAnimator(animator);
        return animator;
    }

    /**
     * Class that defines a TypeEvaluator for a movement along an arc around an axis - see method addAnimatorArcPathAroundAxis().
     */

    private static class EvaluatorTransAttractRepel implements TypeEvaluator<float[]> {
        private ObjectAnimator animator;   // the animator to which this evaluator belongs
        float[] point;  // the point to attract to or repel from
        float[] initial;  // the initial position of the shape
        float[] vector;  // vector between initial position and target position of the shape
        float factor;  // the attract/repel factor
        boolean attributeIsValid;

        // The start position of the animated shape is stored when the animation starts.
        // 'attributeIsValid' specifies if this has been done already.
        EvaluatorTransAttractRepel(float[] point, float factor) {
            this.point = point.clone();
            this.factor = factor;
            this.attributeIsValid = false;
        }

        public void setAnimator(ObjectAnimator animator) {
            this.animator = animator;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (!attributeIsValid) {
                initial = ((GLShapeCV) animator.getTarget()).getTrans();
                vector = new float[3];
                for (int i=0;i<3;i++)
                    vector[i] = (1-factor)*(point[i]-initial[i]);
                attributeIsValid = true;
            }
            float[] retval = new float[3];
            for (int i=0;i<3;i++)
               retval[i] = initial[i]+f*vector[i];
            return retval;
        }

    }

    /**
     * Makes an animator to let a shape jump through a number of discrete points.
     * @param points The set of points, i.e. an array of size [n][3] where the second dimension defines a point with its x, y, and z coordinates.
     *               Point n-1 is the final target of the animation.
     * @param duration The total duration of the animation.
     *                 The animation will let the shape remain in point i (for 0<=i<=n-2) for a time interval of length 'duration/(n-1)'
     *                 and move it in the final instant to point n-1.
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimTransDiscrete(float[][] points, int duration) {
        EvaluatorTransDiscrete eval = new EvaluatorTransDiscrete(points);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject((Object)null,"trans",eval,dummy,dummy);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Makes an animator to let a shape jump through a number of discrete points.
     * @param points The set of points, i.e. an array of size [n][3] where the second dimension defines a point with its x, y, and z coordinates.
     *               Point n-1 is the final target of the animation.
     * @param weights The weights determining the relative times the shape will remain at the individual points.
     *                This parameter may be null in which case the animator will proceed like the animator
     *                produced by the makeAnimTransDiscrete() method without the weights parameter.
     *                Otherwise this parameter must be an array of the same length as the points array or one element shorter.
     *                The array must contain float values all greater than 0.
     *                If it has the same length as the points array the shape will remain at point i (0<=i<=n-1)
     *                for a time length of weigths[i]/sum_of_all_weights*duration.
     *                If it is one element shorter than the points array this formula will apply to all points
     *                except the last one (point n-1) which will be reached at the very end of the animation.
     * @param duration The total duration of the animation.
     * @return The newly generated animator.
     */

    public static ObjectAnimator makeAnimTransDiscrete(float[][] points, float[] weights, int duration) {
        EvaluatorTransDiscrete eval = new EvaluatorTransDiscrete(points,weights);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject((Object)null,"trans",eval,dummy,dummy);
        animator.setDuration(duration);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Class that defines a TypeEvaluator that returns a number of discrete points.
     * For further explanations see the comments for makeAnimTransDiscrete.
     */

    private static class EvaluatorTransDiscrete implements TypeEvaluator<float[]> {

        private final float[][] points;
        private final float[] weights;
        private float[] intervals;
        private int prevIndex = 0;

        EvaluatorTransDiscrete(float[][] points) {
            this(points,null);
        }

        EvaluatorTransDiscrete(float[][] points, float[] weights) {
            this.points = points;
            this.weights = weights;
            if (weights==null) return;
            float sum_weights = 0;
            for (float weight : this.weights)
                sum_weights += weight;
            this.intervals = new float[points.length];
            float prevInterval = 0;
            intervals[0] = 0;
            for (int i = 1; i< this.weights.length; i++) {
               intervals[i] = prevInterval+weights[i-1]/sum_weights;
               prevInterval = intervals[i];
            }
            if (weights.length<points.length)
                intervals[points.length-1]=1;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (weights==null)
                return points[(int)(f*(points.length-1))];
            else {
                // first guess: f lies in the same interval as in the previous call
                if (intervals[prevIndex]<=f&&(prevIndex==intervals.length-1||f<intervals[prevIndex+1]))
                    return points[prevIndex];
                // second guess: f lies in the interval that follows the interval of the previous call
                if (intervals[prevIndex+1]<=f&&(prevIndex+1==intervals.length-1||f<intervals[prevIndex+2])) {
                    prevIndex++;
                    return points[prevIndex];
                }
                // third guess: f lies in the last interval
                if (f>=intervals[intervals.length-1]) {
                    prevIndex=intervals.length-1;
                    return points[intervals.length-1];
                }
                // finally: binary search
                int minIndex=0, maxIndex=intervals.length-1;
                while (minIndex+1<maxIndex) {
                  int midIndex = (minIndex+maxIndex)/2;
                  if (f>=intervals[midIndex])
                      minIndex = midIndex;
                    else
                      maxIndex = midIndex;
                }
                return points[minIndex];
            }
        }

    }

    /**
     * Makes animators to place a shape between two given points, i.e. to translate and to rotate it and (optionally) to scale it.
     * The y axis of the object is rotated, i.e. will afterwards be in line with the two points.
     * YET TO BE TESTED
     * @param point1 The first point.
     * @param point1 The second point.
     * @param scaleX The target scaling factor for the x dimension.
     * @param scaleY The target scaling factor for the y dimension.
     * @param scaleZ The target scaling factor for the z dimension.
     * @param duration The duration of the animation (ms).
     * @return An AnimatorSet playing the animators together.
     */

    public static AnimatorSet makeAnimTransBetween(float[] point1, float[] point2, float scaleX, float scaleY, float scaleZ, int duration) {
        if (point1==null||point1.length!=3||point2==null||point2.length!=3) return null;
        float[] y_axis = {0,1,0};
        float[] midpoint = GraphicsUtilsCV.midpoint3D(point1,point2);
        float[] vectorBetweenPoints = GraphicsUtilsCV.vectorFromTo3D(point1,point2);
        /* Lösung mit ofMultiFloat(), die aber nicht funktioniert
        ObjectAnimator animator;
        // Log.v("GLDEMO","addAnimatorPlaceBetween for "+shape.getId());
        if (Math.abs(vectorBetweenPoints[0])>10e-5||Math.abs(vectorBetweenPoints[2])>10e-5) {
            // rotate only if the rotation axis is not parallel to the y axis
            float rotAxis[] = GraphicsUtilsCV.crossProduct(y_axis, vectorBetweenPoints);
            float rotAngle = (float) Math.toDegrees(Math.acos(GraphicsUtilsCV.dotProduct(y_axis, GraphicsUtilsCV.getNormalizedCopy(GraphicsUtilsCV.vectorBetweenPoints(point1, point2)))));
            float[][] animatorRotParam = new float[2][4];
            animatorRotParam[0][0] = shape.getRotAngle();
            // Log.v("GLDEMO","start angle: "+animatorRotParam[0][0]);
            animatorRotParam[1][0] = shape.getRotAngle()+rotAngle;
            // Log.v("GLDEMO","target angle: "+animatorRotParam[1][0]);
            animatorRotParam[0][1] = animatorRotParam[1][1] = rotAxis[0];
            animatorRotParam[0][2] = animatorRotParam[1][2] = rotAxis[1];
            animatorRotParam[0][3] = animatorRotParam[1][3] = rotAxis[2];
            animator = ObjectAnimator.ofPropertyValuesHolder(shape,
                    PropertyValuesHolder.ofFloat("scaleX", scaleX),
                    PropertyValuesHolder.ofFloat("scaleY", scaleY),
                    PropertyValuesHolder.ofFloat("scaleZ", scaleZ),
                    // bug: setRotationForAnimator() is not called.
                    PropertyValuesHolder.ofMultiFloat("rotationForAnimator", animatorRotParam),
                    PropertyValuesHolder.ofFloat("transX", midpoint[0]),
                    PropertyValuesHolder.ofFloat("transY", midpoint[1]),
                    PropertyValuesHolder.ofFloat("transZ", midpoint[2]));
        } else {
            // Log.v("GLDEMO","addAnimatorPlaceBetween for "+shape.getId()+" - else");
            animator = ObjectAnimator.ofPropertyValuesHolder(shape,
                    PropertyValuesHolder.ofFloat("scaleX", scaleX),
                    PropertyValuesHolder.ofFloat("scaleY", scaleY),
                    PropertyValuesHolder.ofFloat("scaleZ", scaleZ),
                    PropertyValuesHolder.ofFloat("transX", midpoint[0]),
                    PropertyValuesHolder.ofFloat("transY", midpoint[1]),
                    PropertyValuesHolder.ofFloat("transZ", midpoint[2]));
        }
        animator.setDuration(duration);
        shape.addAnimator(animator);
        return animator;
        */
        /* Alternativ: Einzelanimatoren */

        ObjectAnimator animRot = null;
        if (Math.abs(vectorBetweenPoints[0])>10e-5||Math.abs(vectorBetweenPoints[2])>10e-5) {
            // rotate only if the rotation axis is not parallel to the y axis
            float[] rotAxisForShape = GraphicsUtilsCV.crossProduct3D(y_axis, vectorBetweenPoints);
            float rotAngleForShape = (float) Math.toDegrees(Math.acos(GraphicsUtilsCV.dotProduct3D(y_axis, GraphicsUtilsCV.getNormalizedVectorCopy3D(GraphicsUtilsCV.vectorFromTo3D(point1, point2)))));
            animRot = makeAnimRot(rotAngleForShape,rotAxisForShape,duration,0,false);
        }
        ObjectAnimator animScaleX = makeAnimScaleX(scaleX,duration);
        ObjectAnimator animScaleY = makeAnimScaleY(scaleY,duration);
        ObjectAnimator animScaleZ = makeAnimScaleZ(scaleZ,duration);
        ObjectAnimator animTrans = makeAnimTransLinearTo(midpoint,duration);
        AnimatorSet animators = new AnimatorSet();
        if (animRot==null)
            animators.playTogether(animScaleX,animScaleY,animScaleZ,animTrans);
          else
            animators.playTogether(animRot,animScaleX,animScaleY,animScaleZ,animTrans);
        return animators;
    }

    /**
     * Makes an animator to move a shape along an arc around an axis that is specified by two points in 3D space.
     * @param axisPoint1 The first point defining the axis.
     * @param axisPoint2 The second point defining the axis.
     * @param angle The angle of the arc to be traversed.
     * @param duration The duration of the animation (in ms).
     * @param startDelay The start delay of the animation (in ms).
     * @return The new animator
     */

    public static ObjectAnimator makeAnimTransArc(float[] axisPoint1, float[] axisPoint2, float angle, int duration, int startDelay) {
/*
        EvaluatorArcPathAroundAxis eval = new EvaluatorArcPathAroundAxis(shape,axisPoint1,axisPoint2,angle);
        float[] dummy = new float[3];
        ObjectAnimator anim = ObjectAnimator.ofObject(shape,"trans",eval,dummy,dummy);
        anim.setDuration(duration);
        anim.setStartDelay(startDelay);
        shape.addAnimator(anim);
        return anim;
 */
        return makeAnimTransSpiral(axisPoint1,axisPoint2,angle/360,0,duration,startDelay);
    }

    /*
     * Class that defines a TypeEvaluator for a movement along an arc around an axis - see method addAnimatorArcPathAroundAxis().

    private static class EvaluatorTransArc implements TypeEvaluator<float[]> {
        GLShapeCV shape;  // shape to be animated
        float[] axisPoint1;  // first point on the axis
        float[] axisPoint2;  // second point on the axis
        double angle;  // angle of the arc to traverse
        float[] start;  // start position of the shape
        boolean attributeIsValid;

        // The start position of the animated shape is stored when the animation starts.
        // 'attributeIsValid' specifies if this has been done already.
        EvaluatorTransArc(GLShapeCV shape, float[] axisPoint1, float[] axisPoint2, double angle) {
            this.shape = shape;
            this.axisPoint1 = axisPoint1.clone();
            this.axisPoint2 = axisPoint2.clone();
            this.angle = angle;
            this.attributeIsValid = false;
        }

        public float[] evaluate(float f, float dummy1[], float[] dummy2) {
            if (!attributeIsValid) {
                start = shape.getTrans();
                attributeIsValid = true;
            }
            float[] retval = GraphicsUtilsCV.rotateAroundAxis(start,axisPoint1,axisPoint2,(float)(f*angle));
            return retval;
        }

    }

     */

    /**
     * Makes an animator to move a shape in a spiral around an axis. The axis is specified by two points in 3D space.
     * @param axisPoint1 The first point defining the axis.
     * @param axisPoint2 The second point defining the axis.
     * @param turns The number of turns to be made around the axis. If negative, the rotation is clockwise.
     * @param height The height of the spiral.
     * @param duration The duration of the animation (in ms).
     * @param startDelay The start delay of the animation (in ms).
     * @return The new animator
     */

    public static ObjectAnimator makeAnimTransSpiral(float[] axisPoint1, float[] axisPoint2, float turns, float height, int duration, int startDelay) {
        EvaluatorTransSpiral eval = new EvaluatorTransSpiral(axisPoint1,axisPoint2,turns,height);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject((GLShapeCV)null,"trans",eval,dummy,dummy);
        eval.setAnimator(animator);
        animator.setDuration(duration);
        animator.setStartDelay(startDelay);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     * Class that defines a TypeEvaluator for a movement along a spiral around an axis - see method addAnimatorSpiralPath().
     */

    private static class EvaluatorTransSpiral implements TypeEvaluator<float[]> {
        private ObjectAnimator animator;   // the animator to which this evaluator belongs
        float[] axisPoint1;  // first point on the axis
        float[] axisPoint2;  // second point on the axis
        float[] normedAxisVector; // a vector defining the axis with length 'height'
        float angle;  // angle of the arc to traverse
        float[] start;  // start position of the shape
        boolean attributeIsValid;

        // The start position of the animated shape is stored when the animation starts.
        // 'attributeIsValid' specifies if this has been done already.
        EvaluatorTransSpiral(float[] axisPoint1, float[] axisPoint2, float turns, float height) {
            this.axisPoint1 = axisPoint1.clone();
            this.axisPoint2 = axisPoint2.clone();
            this.angle = turns*360;
            normedAxisVector = new float[3];
            float dist = GraphicsUtilsCV.distance3D(axisPoint1,axisPoint2);
            if (dist!=0)
                for (int i=0; i<3; i++)
                    normedAxisVector[i] = (axisPoint2[i]-axisPoint1[i])*height/dist;
            this.attributeIsValid = false;
        }

        public void setAnimator(ObjectAnimator animator) {
            this.animator = animator;
        }

        public float[] evaluate(float f, float[] dummy1, float[] dummy2) {
            if (!attributeIsValid) {
                GLShapeCV shape = (GLShapeCV) animator.getTarget();
                start = shape.getTrans();
                attributeIsValid = true;
            }
            float[] retval = GraphicsUtilsCV.rotateAroundAxis(start,axisPoint1,axisPoint2,f*angle);
            for (int i=0; i<3; i++)
                retval[i] += f*normedAxisVector[i];
            return retval;
        }

    }

    /** Makes an animator to move the object along a quadratic Bezier curve.
     *
     * @param control control point
     * @param target target point
     * @param duration Duration of the animation (in ms)
     * @param startDelay Start delay of the animation (in ms)
     * @return The new animator
     */

    public static ObjectAnimator makeAnimTransBezier(float[] control, float[] target, int duration, int startDelay) {
        return makeAnimTransBezier(control,target,-1,duration,startDelay);
    }

    /** Makes an animator to move a shape along a quadratic Bezier curve.
     * @param control control point
     * @param target target point
     * @param axisToAlign specifies if the shape shall be aligned with its current movement direction:
     *                    -1 = no alignment, 0/1/2 = alignment of the shape's x/y/z axis
     * @param duration Duration of the animation (in ms)
     * @param startDelay Start delay of the animation (in ms)
     * @return The new animator
     */

    public static ObjectAnimator makeAnimTransBezier(float[] control, float[] target, int axisToAlign, int duration, int startDelay) {
        EvaluatorTransBezier_ConstSpeed eval = new EvaluatorTransBezier_ConstSpeed(control,axisToAlign);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject((GLShapeCV)null,"trans",eval,dummy,target);
        eval.setAnimator(animator);
        animator.setDuration(duration);
        animator.setStartDelay(startDelay);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /** Makes an animator to move a shape along a cubic Bezier curve.
     * @param control1 first control point
     * @param control2 second control point
     * @param target target point
     * @param duration Duration of the animation (in ms)
     * @param startDelay Start delay of the animation (in ms)
     * @return The new animator
     */

    public static ObjectAnimator makeAnimTransBezier(float[] control1, float[] control2, float[] target, int duration, int startDelay) {
        return makeAnimTransBezier(control1,control2,target,-1,duration,startDelay);
    }

    /** Makes an animator to move a shape along a cubic Bezier curve.
     * Adds the new animator to the animators of the shape.
     * @param control1 first control point
     * @param control2 second control point
     * @param target target point
     * @param axisToAlign specifies if the shape shall be aligned with its current movement direction:
     *                    -1 = no alignment, 0/1/2 = alignment of the shape's x/y/z axis
     * @param duration Duration of the animation (in ms)
     * @param startDelay Start delay of the animation (in ms)
     * @return The new animator
     */

    public static ObjectAnimator makeAnimTransBezier(float[] control1, float[] control2, float[] target, int axisToAlign, int duration, int startDelay) {
        EvaluatorTransBezier_ConstSpeed eval = new EvaluatorTransBezier_ConstSpeed(control1,control2,axisToAlign);
        float[] dummy = new float[1];
        ObjectAnimator animator = ObjectAnimator.ofObject((GLShapeCV)null,"trans",eval,dummy,target);
        eval.setAnimator(animator);
        animator.setDuration(duration);
        animator.setStartDelay(startDelay);
        animator.setInterpolator(new LinearInterpolator());
        return animator;
    }

    /**
     *  Class that defines a TypeEvaluator for a movement along a Bezier curve of order 2 or 3 - see method addAnimatorBezierPath().
     *  Note that this evaluator does not ensure that the shape moves along the curve with a constant speed.
     *  If this is required use EvaluatorTransBezier_ConstSpeed instead.
     */

    private static class EvaluatorTransBezier implements TypeEvaluator<float[]> {

        private ObjectAnimator animator;   // the animator to which this evaluator belongs

        private final int order; // order of the Bezier curve: 2 = quadratic, 3 = cubic; all other values are undefined */

        /** first control point */

        private final float[] contr1;

        /** second control point */

        private float[] contr2;

        /** position of the shape when the animation starts */

        private float[] start;

        /** the previous position of the shape */

        private float[] prevPos;

        private int axisToAlign = -1;

        /** Constructor for a quadratic Bezier curve
         *
         * @param contr1 Control point of the curve
         */

        EvaluatorTransBezier(float[] contr1, int axisToAlign) {
            this.start = null;
            this.contr1 = contr1.clone();
            this.order = 2;
            this.axisToAlign = axisToAlign;
        }

        /** Constructor for a cubic Bezier curve
         *
         * @param contr1 First control point of the curve
         * @param contr2 Second control point of the curve
         */

        EvaluatorTransBezier(float[] contr1, float[] contr2, int axisToAlign) {
            this.start = null;
            this.contr1 = contr1.clone();
            this.contr2 = contr2.clone();
            this.order = 3;
            this.axisToAlign = axisToAlign;
        }

        public void setAnimator(ObjectAnimator animator) {
            this.animator = animator;
        }

        /** Evaluator */

        public float[] evaluate(float f, float[] dummy, float[] target) {
            float[] result = new float[3];
            if (start==null) {
                start = ((GLShapeCV) animator.getTarget()).getTrans();
                prevPos = start;
            }
            if (order==2)
                result = GraphicsUtilsCV.bezier(f,start,contr1,target);
            else
                result = GraphicsUtilsCV.bezier(f,start,contr1,contr2,target);
            if (axisToAlign>=0 && GraphicsUtilsCV.distance3D(prevPos,result)>0.2) {
                float[] vector = new float[3];
                for (int i=0;i<3;i++)
                    vector[i] = result[i]- prevPos[i];
                ((GLShapeCV) animator.getTarget()).alignWith(axisToAlign,vector,0,0,0);
                prevPos = result.clone();
            }
            return result;
        }

    }

    /**
     *  Class that defines a TypeEvaluator for a movement along a Bezier curve of order 2 or 3 - see method addAnimatorBezierPath().
     *  This evaluator ensures (in contrast to EvaluatorTransBezier) that the shape moves along the curve with a constant speed.
     */

    private static class EvaluatorTransBezier_ConstSpeed implements TypeEvaluator<float[]> {

        private ObjectAnimator animator;   // the animator to which this evaluator belongs

        private final int order; // order of the Bezier curve: 2 = quadratic, 3 = cubic; all other values are undefined */

        private final float[] contr1; // first control point

        private float[] contr2; // second control point

        private float[][] points; // points on the Bezier curve to traverse

        private final int noOfPoints = 10000; // number of points to traverse

        private float[] distances; // distances between the points

        private float[] intervals; // specification of which t values will be mapped to which points:
                                   // if intervals[i]<=t<intervaks[i+1] the evaluator will return points[i]
        private int prevIndex = 0;

        private float[] prevPoint;

        private final int axisToAlign;

        private boolean attributesAreValid;

        /** Constructor for a quadratic Bezier curve
         * @param contr1 Control point of the curve
         */

        EvaluatorTransBezier_ConstSpeed(float[] contr1, int axisToAlign) {
            this.contr1 = contr1.clone();
            this.order = 2;
            this.axisToAlign = axisToAlign;
            this.attributesAreValid = false;
        }

        /** Constructor for a cubic Bezier curve
         * @param contr1 First control point of the curve
         * @param contr2 Second control point of the curve
         */

        EvaluatorTransBezier_ConstSpeed(float[] contr1, float[] contr2, int axisToAlign) {
            this.contr1 = contr1.clone();
            this.contr2 = contr2.clone();
            this.order = 3;
            this.axisToAlign = axisToAlign;
            this.attributesAreValid = false;
        }

        public void setAnimator(ObjectAnimator animator) {
            this.animator = animator;
        }

        /** Evaluator */

        public float[] evaluate(float f, float[] dummy, float[] target) {
            if (!attributesAreValid) {
                points = new float[noOfPoints][3];
                distances = new float[noOfPoints];
                float[] start = ((GLShapeCV) animator.getTarget()).getTrans();
                points[0] = GraphicsUtilsCV.bezier(0,start,contr1,contr2,target);
                float totalDistance = 0;
                for (int i=1;i<noOfPoints;i++) {
                    points[i] = GraphicsUtilsCV.bezier((float)i/(noOfPoints-1),start,contr1,contr2,target);
                    distances[i-1] = GraphicsUtilsCV.distance3D(points[i-1],points[i]);
                    totalDistance += distances[i-1];
                }
                this.intervals = new float[points.length];
                float prevInterval = 0;
                intervals[0] = 0;
                for (int i = 1; i< this.distances.length; i++) {
                    intervals[i] = prevInterval+distances[i-1]/totalDistance;
                    prevInterval = intervals[i];
                }
                if (distances.length<points.length)
                    intervals[points.length-1]=1;
                prevPoint = start;
                attributesAreValid = true;
            }
            int resultIndex;
            if (intervals[prevIndex]<=f&&(prevIndex==intervals.length-1||f<intervals[prevIndex+1]))
                resultIndex=prevIndex;
            // second guess: f lies in the interval that follows the interval of the previous call
            else if (intervals[prevIndex+1]<=f&&(prevIndex+1==intervals.length-1||f<intervals[prevIndex+2])) {
                prevIndex++;
                resultIndex=prevIndex;
            }
            // third guess: f lies in the last interval
            else if (f>=intervals[intervals.length-1]) {
                prevIndex=intervals.length-1;
                resultIndex=intervals.length-1;
            }
            // finally: binary search
            else {
                int minIndex = 0, maxIndex = intervals.length - 1;
                while (minIndex + 1 < maxIndex) {
                    int midIndex = (minIndex + maxIndex) / 2;
                    if (f >= intervals[midIndex])
                        minIndex = midIndex;
                    else
                        maxIndex = midIndex;
                }
                resultIndex = minIndex;
            }
            if (axisToAlign>=0 && GraphicsUtilsCV.distance3D(prevPoint,points[resultIndex])>0.2) {
                float[] vector = new float[3];
                for (int i=0;i<3;i++)
                    vector[i] = points[resultIndex][i]-prevPoint[i];
                ((GLShapeCV) animator.getTarget()).alignWith(axisToAlign,vector,0,0,0);
                prevPoint = points[resultIndex];
            }
            return points[resultIndex];
        }

    }

    /**
     * Method to specify a sequence of transition animations, i.e. a path through which a shape shall run.
     * @param totalDuration The total duration of the whole sequence. It will be distributed over the individual animators such that the shape will always have a constant speed.
     * @param animatorTypes The types of the animators to be sequenced
     *                      (currently supported: "LinearToX", "LinearToY", "LinearToZ", "LinearTo", and "Bezier"
     *                       as in the makeAnimTransXXX() methods with the corresponding names).
     * @param animatorArgs A list with exactly one element more than 'animatorTypes' specifying the start and end points of the individual animators.
     *                     list entry #0: x,y,z of the start position of the whole sequence (and therefore its first animator)
     *                     list entry #n: pos. 0-2 target position of the n-1 th animator
     *                                    pos. 3-5 control point (only in case of a quadratic Bezier animator)
     *                                    pos. 6-8 second control point (only in case of a cubic Bezier animator)
     *                     If, for a Bezier animator, the previous and following animators are both of a linear type, the control point may be omitted,
     *                     i.e. it is sufficient to specify the end point of the intermediate Bezier path.
     *                     In this case, the two lines defined by the previous and the following linear animators will be taken
     *                     and their intersection or the midpoint of the shortest line segment between these lines is used as the control point of a quadratic Bezier animator.
     *                     This shall ensure a smooth transition between the two linear segments.
     *                     (N.B. Works only if the shape is moving on the first line into the direction of the intersection.)
     */

    static public AnimatorSet makeAnimTransSequence(long totalDuration, ArrayList<String> animatorTypes, ArrayList<float[]> animatorArgs) {
        float[] lengths = new float[animatorTypes.size()];
        ArrayList<Animator> animators = new ArrayList<>();
        for (int i=0;i<animatorTypes.size();i++) {
            float[] current = Arrays.copyOfRange(animatorArgs.get(i), 0, 3);
            float[] target = Arrays.copyOfRange(animatorArgs.get(i+1), 0, 3);
            switch (animatorTypes.get(i)) {
                case "LinearToX":
                    animators.add(makeAnimTransLinearToX(target[0], 0));
                    lengths[i] = Math.abs(target[0]-current[0]);
                    break;
                case "LinearToY":
                    animators.add(makeAnimTransLinearToY(target[1], 0));
                    lengths[i] = Math.abs(target[1]-current[1]);
                    break;
                case "LinearToZ":
                    animators.add(makeAnimTransLinearToZ(target[2], 0));
                    lengths[i] = Math.abs(target[2]-current[2]);
                    break;
                case "LinearTo":
                    animators.add(makeAnimTransLinearTo(target, 0));
                    lengths[i] = GraphicsUtilsCV.distance3D(target,current);
                    break;
                case "Arc": break;  // TBD
                case "Spiral": break;  // TBD
                case "Bezier":
                    float[] control1 = null, control2 = null;
                    switch (animatorArgs.get(i+1).length) {
                        case 3:  // no control point given:
                            // check if the previous and the following animators specify a linear transition
                            if (i==0||!animatorTypes.get(i-1).equals("LinearTo")||i==animatorTypes.size()-1||!animatorTypes.get(i+1).equals("LinearTo"))
                                return null;
                            // if so: calculate the control point of the quadratic Bezier curve as the intersection
                            // of the two lines going through the previous and following linear animation segment
                            // or as the midpoint of the shortest segments between these lines
                            float[] prevSegmentStart = animatorArgs.get(i-1);
                            float[] prevSegmentEnd = animatorArgs.get(i);
                            float[] nextSegmentStart = animatorArgs.get(i+1);
                            float[] nextSegmentEnd = animatorArgs.get(i+2);
                            float[] intersectionOrShortestSegment = GraphicsUtilsCV.lineIntersectionOrShortestConnection3D(prevSegmentStart,prevSegmentEnd,nextSegmentStart,nextSegmentEnd);
                            if (intersectionOrShortestSegment==null) return null;
                            if (intersectionOrShortestSegment.length==3)  // intersection
                                control1 = intersectionOrShortestSegment;
                              else { // midpoint of the connecting segment
                                control1 = new float[3];
                                for (int j = 0; j < 3; j++)
                                    control1[j] = (intersectionOrShortestSegment[j] + intersectionOrShortestSegment[j + 3]) / 2;
                                }
                            break;
                        case 6:  // one control point given: quadratic Bezier curve
                            control1 = Arrays.copyOfRange(animatorArgs.get(i+1), 3, 6);
                            break;
                        case 9:  // two control points given: cubic Bezier curve
                            control1 = Arrays.copyOfRange(animatorArgs.get(i+1), 3, 6);
                            control2 = Arrays.copyOfRange(animatorArgs.get(i + 1), 6, 8);
                            break;
                    }
                    if (control2==null)
                        animators.add(makeAnimTransBezier(control1, target, 0, 0));
                      else
                        animators.add(makeAnimTransBezier(control1, control2, target, 0, 0));
                    lengths[i] = GraphicsUtilsCV.bezierLength(current, control1, control2, target);
                    break;
                default:
                    return null;
            }
        }
        float sumLengths = 0;
        for (float length : lengths)
            sumLengths += length;
        if (sumLengths==0) return null;
        int lengthsIndex = 0;
        for (Animator animator : animators)
            animator.setDuration((int) (lengths[lengthsIndex++] / sumLengths * totalDuration));
        AnimatorSet animSet = new AnimatorSet();
        animSet.playSequentially(animators);
        return animSet;
    }

    /**
     * Class for listeners that shall be executed when an animation ends
     * and that will remove the animated shape from the surface view.
     */

    public static class EndListenerRemove extends AnimatorListenerAdapter {
        private final GLShapeCV shape;
        private final GLSurfaceViewCV surfaceView;
        public EndListenerRemove(GLShapeCV shape, GLSurfaceViewCV surfaceView) {
            this.shape = shape;
            this.surfaceView = surfaceView;
        }
        @Override
        public void onAnimationEnd(Animator animator) {
            surfaceView.removeShape(shape);
        }
    }

    /**
     * Class for listeners that shall execute a specific action after a number of animations has ended.
     * The idea is to register a listener object of this class with multiple animations
     * and have this listener execute the action when the last of these animations has ended.
    */

    public static class EndListenerMultipleAnimations extends AnimatorListenerAdapter {

        private int numberToEnd;  // see constructor comment
        private final Runnable action;  // see constructor comment

        /**
         * @param numberToEnd Number of animations to end: A counter is initialized with this number and decremented each time onAnimationEnd() is called.
         *                    When is reaches 0 the action as specified by the 'action' attribute is executed.
         * @param action The action to be executed, specified by the run() method of some Runnable object.
         *               Note that the action is executed by the calling thread, i.e. that no new thread for the Runnable is started.
         */

        public EndListenerMultipleAnimations(int numberToEnd, Runnable action) {
            this.numberToEnd = numberToEnd;
            this.action = action;
        }

        /**
         * This method decrements the counter and executes the action when the counter has reached 0.
         * @param animator
         */

        @Override
        public void onAnimationEnd(Animator animator) {
            synchronized(this) {
                numberToEnd--;
                try {
                    ((GLShapeCV)((ObjectAnimator)animator).getTarget()).removeAnimator(animator);
                } catch (ClassCastException exc) {}
                if (numberToEnd==0)
                    action.run();
            }
        }

    }

}